/**
 * zerolite: pglite-powered zero-sync development backend.
 *
 * starts a pglite instance, tcp proxy, s3 server, and zero-cache
 * process. replaces docker-based postgresql, zero-cache, and minio
 * with a single `bun run` command.
 */

import { resolve, join } from 'node:path'
import {
  existsSync,
  readFileSync,
  mkdirSync,
  writeFileSync,
  unlinkSync,
} from 'node:fs'
import { spawn, type ChildProcess } from 'node:child_process'

import type { PGlite } from '@electric-sql/pglite'
import type { Server } from 'node:net'
import type { Server as HttpServer } from 'node:http'

import { getConfig, getConnectionString } from './config'
import { installChangeTracking } from './replication/change-tracker'
import { createPGliteInstance, runMigrations } from './pglite-manager'
import { startPgProxy } from './pg-proxy'
import { startS3Server } from './s3-local'

import type { ZeroLiteConfig } from './config'

export type { ZeroLiteConfig } from './config'
export { getConfig, getConnectionString } from './config'

export async function startZeroLite(overrides: Partial<ZeroLiteConfig> = {}) {
  const config = getConfig(overrides)
  console.info('[zerolite] starting...')
  console.info(`[zerolite] data dir: ${resolve(config.dataDir)}`)

  mkdirSync(config.dataDir, { recursive: true })

  // start pglite
  const db = await createPGliteInstance(config)

  // run migrations
  await runMigrations(db, config)

  // install change tracking
  console.info('[zerolite] installing change tracking')
  await installChangeTracking(db)

  // start tcp proxy
  const pgServer = await startPgProxy(db, config)

  // start s3 server
  const s3Server = await startS3Server(config)

  // seed data if needed
  await seedIfNeeded(db, config)

  // write .env.local so `bun dev` connects to zerolite ports
  writeEnvLocal(config)

  // start zero-cache
  console.info('[zerolite] starting zero-cache...')
  const zeroCacheProcess = await startZeroCache(config)

  // wait for zero-cache to be healthy
  await waitForZeroCache(config)

  const stop = async () => {
    console.info('[zerolite] shutting down...')
    if (zeroCacheProcess) {
      zeroCacheProcess.kill('SIGTERM')
    }
    pgServer.close()
    s3Server.close()
    await db.close()
    cleanupEnvLocal()
    console.info('[zerolite] stopped')
  }

  return { config, stop }
}

const ENV_LOCAL_PATH = resolve('.env.local')
const ENV_LOCAL_MARKER = '# auto-generated by zerolite'

function writeEnvLocal(config: ZeroLiteConfig): void {
  const upstreamUrl = getConnectionString(config, 'postgres')
  const cvrUrl = getConnectionString(config, 'zero_cvr')
  const cdbUrl = getConnectionString(config, 'zero_cdb')

  const content = `${ENV_LOCAL_MARKER}
VITE_PORT_POSTGRES=${config.pgPort}
VITE_PORT_ZERO=${config.zeroPort}
VITE_PORT_MINIO=${config.s3Port}
VITE_PUBLIC_ZERO_SERVER="http://localhost:${config.zeroPort}"
ZERO_UPSTREAM_DB="${upstreamUrl}"
ZERO_CVR_DB="${cvrUrl}"
ZERO_CHANGE_DB="${cdbUrl}"
CLOUDFLARE_R2_ENDPOINT="http://localhost:${config.s3Port}"
CLOUDFLARE_R2_PUBLIC_URL="http://localhost:${config.s3Port}"
`
  writeFileSync(ENV_LOCAL_PATH, content)
  console.info('[zerolite] wrote .env.local for dev server')
}

function cleanupEnvLocal(): void {
  try {
    if (existsSync(ENV_LOCAL_PATH)) {
      const content = readFileSync(ENV_LOCAL_PATH, 'utf-8')
      if (content.startsWith(ENV_LOCAL_MARKER)) {
        unlinkSync(ENV_LOCAL_PATH)
        console.info('[zerolite] cleaned up .env.local')
      }
    }
  } catch {
    // ignore cleanup errors
  }
}

async function seedIfNeeded(
  db: PGlite,
  config: ZeroLiteConfig
): Promise<void> {
  // check if we already have data
  try {
    const result = await db.query<{ count: string }>(
      'SELECT count(*) as count FROM public."user"'
    )
    if (Number(result.rows[0].count) > 0) {
      return
    }
  } catch {
    // table might not exist yet
  }

  console.info('[zerolite] seeding demo data...')
  const seedFile = resolve(config.seedFile)
  if (!existsSync(seedFile)) {
    console.info('[zerolite] no seed file found, skipping')
    return
  }

  const sql = readFileSync(seedFile, 'utf-8')
  const statements = sql
    .split('--> statement-breakpoint')
    .map((s) => s.trim())
    .filter(Boolean)

  for (const stmt of statements) {
    await db.exec(stmt)
  }
  console.info('[zerolite] seeded demo data')
}

async function startZeroCache(
  config: ZeroLiteConfig
): Promise<ChildProcess> {
  // find zero-cache binary
  const zeroCachePaths = [
    resolve('node_modules/.bin/zero-cache'),
    resolve(
      'node_modules/@rocicorp/zero/out/zero-cache/src/bin/main.js'
    ),
  ]

  let zeroCacheBin = ''
  for (const p of zeroCachePaths) {
    if (existsSync(p)) {
      zeroCacheBin = p
      break
    }
  }

  if (!zeroCacheBin) {
    throw new Error(
      'zero-cache binary not found. install @rocicorp/zero'
    )
  }

  const upstreamUrl = getConnectionString(config, 'postgres')
  const cvrUrl = getConnectionString(config, 'zero_cvr')
  const cdbUrl = getConnectionString(config, 'zero_cdb')

  const env: Record<string, string> = {
    ...(process.env as Record<string, string>),
    NODE_ENV: 'development',
    ZERO_UPSTREAM_DB: upstreamUrl,
    ZERO_CVR_DB: cvrUrl,
    ZERO_CHANGE_DB: cdbUrl,
    ZERO_REPLICA_FILE: resolve(config.dataDir, 'zero-replica.db'),
    ZERO_PORT: String(config.zeroPort),
    ZERO_MUTATE_URL: `http://localhost:${config.webPort}/api/zero/push`,
    ZERO_QUERY_URL: `http://localhost:${config.webPort}/api/zero/pull`,
    ZERO_LOG_LEVEL: 'info',
    ZERO_NUM_SYNC_WORKERS: '1',
    DO_NOT_TRACK: '1',
  }

  const child = spawn(zeroCacheBin, [], {
    env,
    stdio: ['ignore', 'pipe', 'pipe'],
  })

  child.stdout?.on('data', (data: Buffer) => {
    const lines = data.toString().trim().split('\n')
    for (const line of lines) {
      console.info(`[zero-cache] ${line}`)
    }
  })

  child.stderr?.on('data', (data: Buffer) => {
    const lines = data.toString().trim().split('\n')
    for (const line of lines) {
      console.info(`[zero-cache] ${line}`)
    }
  })

  child.on('exit', (code) => {
    if (code !== 0 && code !== null) {
      console.info(`[zero-cache] exited with code ${code}`)
    }
  })

  return child
}

async function waitForZeroCache(
  config: ZeroLiteConfig,
  timeoutMs = 60000
): Promise<void> {
  const start = Date.now()
  const url = `http://127.0.0.1:${config.zeroPort}/`

  while (Date.now() - start < timeoutMs) {
    try {
      const res = await fetch(url)
      if (res.ok) {
        console.info('[zerolite] zero-cache is ready')
        return
      }
    } catch {
      // not ready yet
    }
    await new Promise((r) => setTimeout(r, 500))
  }

  console.info(
    '[zerolite] warning: zero-cache health check timed out, continuing anyway'
  )
}
